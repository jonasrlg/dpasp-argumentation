% Appendix Sat

\chapter{Appendix Satisfiability and Proof Theory}

\label{ch:sat}

% %---------------------------------------------------------------

Logic revolves around two tightly linked notions: \textit{consistency} and
\textit{validity} \citep{franco2009history}. Proof theory studies these notions
from a syntactic perspective by manipulating symbols using axioms and inference
rules; model theory examines them semantically by interpreting sentences over
structures that encode the ``world''. Although the two views emphasise different
objects, they coincide for complete axiom systems: a statement that can be
derived syntactically is precisely one that is true in every model, and
unsatisfiable theories are those that entail a contradiction.

The bridge between proof theory and model theory is central to this thesis.
Efficient algorithms for propositional satisfiability (SAT) allow us to reason
about the models of logic programs, while proofs about circuit properties ensure
that the compiled artefacts faithfully capture the semantics of the original
theories. Shannon's connection between Boolean logic and circuits
\citep{shannon1938symbolic} sparked a line of work that culminated in modern
knowledge compilation techniques, such as Binary Decision Diagrams (BDDs)
\citep{akers1978binary, bryant1986graph} and Sentential Decision Diagrams (SDDs).
These structures will later support our probabilistic Answer Set Programming
encodings.

% %---------------------------------------------------------------

\section{Notation}

We borrow definitions and notation from the work of \citep{arora2009computational}
and \citep{kimmig2017algebraic}. Since this chapter is focused on logical
SAT-like problems, we only introduce basic logic concepts, such as
\textit{Boolean formulas}, CNFs and \textit{Logical Propositional
Theories}.

\begin{definition}[Boolean Formulas]
    A \textit{Boolean formula}
    is the combination of \textit{Boolean variables}, that can
    be either $\top$ or $\bot$, and logical operators, such as
    $\land$ ($AND$), $\lor$ ($OR$), $\lnot$ ($NOT$, also denoted
    by an overline) \citep{arora2009computational}.
\end{definition}

\begin{example}
    For example, the formula $\phi$ defined by
    \begin{displaymath}
       \phi = (u_1 \land u_2) \lor \lnot (u_3 \land
       \overline{u}_4)
    \end{displaymath}
    is a Boolean formula over variables $u_1, u_2, u_3, u_4$.
    We denote by $\phi(a)$ the evaluation of $\phi$ over an
    assignment $a$ of the variables in the formula.

\end{example}

\begin{definition}[Conjunctive Normal Form]
    \label{def:cnf}
    A Boolean formula over variables $u_1, \ldots u_n$ is in
    CNF if it is a conjunction of clauses, where each
    clause is a disjunction of literals, and a literal is either
    a variable or its negation \citep{arora2009computational}.
    Hence, a CNF is a Boolean formula of the form
    \begin{displaymath}
        \bigwedge_i \left ( \bigvee_j v_{ij} \right ),
    \end{displaymath}

    where each $v_{ij}$ is a literal over variables $u_1,
    \ldots u_n$.
\end{definition}

\begin{example}
   For example, the following formula is a 3CNF (a CNF where
   each clause has at most 3 literals) over variables $u_1, u_2,
   u_3, u_4$:
    \begin{displaymath}
        (u_1 \lor \overline{u}_2 \lor u_3) \land (u_2 \lor
        \overline{u}_3 \lor u_4) \land (\overline{u}_1 \lor
        u_3 \lor \overline{u}_4).
    \end{displaymath}
\end{example}

\begin{definition}[Disjunctive Normal Form]
    A Boolean formula over variables $u_1, \ldots u_n$ is in
    DNF if it is a disjunction of clauses, where each
    clause is a conjunction of literals. Hence, a DNF is a
    Boolean formula of the form:
    \begin{displaymath}
        \bigvee_i \left ( \bigwedge_j v_{ij} \right ),
    \end{displaymath}
    where each $v_{ij}$ is a literal over variables $u_1,
    \ldots u_n$.
\end{definition}

\begin{definition}[Logical Propositional Theory]
    A \textit{Logical Theory} is set of logical sentences,
    Boolean-valued formulas with no free variables. Hence, a
    \textit{Propositional Theory} is Logical Theory where the
    sentences are propositional formulas, i.e., formulas with
    no quantifiers.
\end{definition}

%------------------------------------------------

\section{Satisfiability}

Propositional satisfiability (SAT) is one of the cornerstones of theoretical
computer science. Every problem in NP polynomially reduces to SAT, which
establishes its NP-completeness \citep{Cook_1971, levin1973universal}. Because
of this universality, SAT provides a convenient target for reasoning about
diverse logical theories. Later chapters will rely on SAT when translating PASP
encodings into propositional form so that we can leverage mature SAT and model
counting machinery.

In neuro-symbolic settings we seldom solve SAT just once; instead we evaluate
many related queries that differ by evidence or parameter values. This calls
for solving SAT-like problems in a way that enables reuse, motivating the
knowledge compilation techniques studied throughout this thesis. We therefore
start by recalling baseline notions of satisfiability and its counting and
optimization variants.

\subsection{Satisfiability}

The Boolean Satisfiability Problem is the problem of
determining whether a given CNF is \textit{satisfiable},
i.e., whether there is an assignment of $True$ or $False$ to the
variables that makes the formula $True$
\citep{arora2009computational}. If such an assignment does not
exist, the formula is said to be \textit{unsatisfiable}.

\begin{definition}[SAT - Satisfiability]
    Let SAT be the language of all satisfiable CNFs.
    Then, we say that for a CNF $\phi$, the SAT
    problem is defined as

    \begin{displaymath}
        \text{SAT}(\phi) = \{ \phi \mid \phi \text{ is a
        satisfiable propositional formula} \}.
    \end{displaymath}

\end{definition}

For example, $(True, False, False, False)$ is an example of
assignment that makes the 3CNF of definition \ref{def:cnf}
satisfiable. On the other hand, the CNF $x \land
\overline{x}$ is unsatisfiable, since it is a
\textit{contradiction} (the opposite of a tautology).

\subsection{MAX-SAT}

The Max-SAT problem is the problem of finding an assignment
that satisfies the maximum number of clauses in a given CNF
\citep{KRENTEL1988490}.

\begin{definition}[MAX-SAT]
    Formally, let $\phi$ be a
    CNF over variables $x_1, \ldots, x_n$. Then, the
    Max-SAT problem is to find an assignment $a$ that maximizes the
    sum of the Iverson brackets of the clauses in $C$, such that:
    \begin{displaymath}
        \phi(a) = \bigwedge_{c \in C} c(a),
    \end{displaymath}
    where $c(a)$ is the evaluation of $c$ over the assignment $a$, and
    $[\!\![c(a)]\!\!]$ is the Iverson bracket, which is equal to $1$ if $c(a)$
    is $True$, and $0$ otherwise.
\end{definition}

Sometimes, the Max-SAT problem refers to the weighted
version of the problem, where each clause has a non-negative
weight, and the goal is to maximize the sum of the weights
of the satisfied clauses.

\begin{definition}[Weighted MAX-SAT]
    Formally, let $\phi$ be a CNF over variables $x_1,
    \ldots, x_n$, and let $w: C \rightarrow \mathbb{R}^+$ be the
    weight function over the clauses of $\phi$. Then, this
    variant of the Max-SAT problem, called \textit{Weighted} Max-SAT, is defined
    as the problem of finding an assignment $a$ such that it maximizes the
    following:
    \begin{displaymath}
        \sum_{c \in C} w(c) \cdot [\!\![ c(a) ]\!\!],
    \end{displaymath}
    subject to the constraint that
    \begin{displaymath}
        \phi(a) = \bigwedge_{c \in C} c(a).
    \end{displaymath}
\end{definition}

An interesting difference between the SAT and Max-SAT
is that the former is a decision problem, while the latter is an
optimization problem. Another relation between them is that
SAT is a special case of the Max-SAT, where it is
possible to obtain a solution where the maximum number of
possible clauses satisfied is the total number of clauses. Thus,
there is a reduction from SAT to Max-SAT, which is
polynomial in time. Moreover, because of this reduction, one can
claim that the Max-SAT problem is NP-hard, since
SAT is NP-complete.

The reduction from Max-SAT to weighted Max-SAT is
simple too: just set all weights to $1$ (or any other constant),
and the problem is reduced to the unweighted version. Therefore,
the weighted version of the problem is also NP-hard, as one
would expect. Moreover, the Max-SAT problem is also
OptP-complete (Optimization Polynomial Time), similar to the
\textit{Traveling Salesman} and \textit{Knapsack} problems \citep{KRENTEL1988490}.

\subsection{Sharp-SAT}

Differently from the SAT and Max-SAT problems, the
$\#SAT$ (or Sharp-SAT) problem is a counting problem, where
the goal is to count the number of solutions of a given CNF
has \citep{valiant1979189}. Therefore, one can see the
Sharp-SAT problem closer to Levin studied problems
\citep{levin1973universal} than Cook's \citep{Cook_1971}, in the
sense that the goal is to retrieve a solution, because there
will always be one. A way to perform this computation would be
a search problem over \textbf{all} possible assignments over the
variables of the CNF, and count the number of them that
satisfy the formula. Note that this is different from search
problems, where finding one solution solves the problem, and the
search can be stopped.

This relation between Sharp-SAT and SAT variations
does not stop here. The Sharp-SAT is clearly NP-hard,
since it is possible to reduce SAT to Sharp-SAT in
polynomial time, because knowing the number of solutions of a
CNF is equivalent to knowing whether it has at least one
solution. Moreover, Sharp-SAT is a Sharp-P-complete
problem (or $\#P\mathrm{-complete}$), which means that it is
capable of reducing the set of the counting problems associated
with the decision problems in the set NP.

\begin{definition}[\#SAT]
    Formally, let $\phi$ be a CNF over variables $x_1,
    \ldots, x_n$. Then, the Sharp-SAT  problem is to find
    the natural number $n$ such that
    \begin{displaymath}
        \#SAT(\phi) = | \{ a \in \{0,1\}^n \mid a \text{ is an
        assignment of } \phi \}|.
    \end{displaymath}
\end{definition}

Similar to the Max-SAT problem, there is a weighted version
of the Sharp-SAT problem, called Weighted Model Counting (WMC), where a
non-negative weight is associated to each assignment of values
to variables \citep{chakraborty2015weighted}. The classical
version of the problem, usually called Model Counting (MC), can be seen as
a special case of the weighted version, where all weights are
equal to $1$, and is sometimes referred to as \textit{unweighted
model counting}.

\begin{definition}[Weighted Model Counting]
    The Weighted Model Counting problem is the problem of finding the sum of
    the weights of all assignments that satisfy a given
    CNF. Formally, let $\phi$ be a CNF over variables
    $x_1, \ldots, x_n$, and let $w: \{0,1\}^n \rightarrow
    \mathbb{R}^+$ be the weight function over the assignments of
    the variables in $\phi$. Then, the WMC problem is
    \begin{displaymath}
        \text{WMC}(\phi) = \sum_{a \in \{0,1\}^n} w(a) \cdot
        [\!\![ \phi(a) ]\!\!].
    \end{displaymath}
\end{definition}

Weighted model counting subsumes the previous variants: setting all weights to
$1$ recovers model counting, while restricting weights to $\{0,1\}$ captures
ordinary SAT. In Chapter \autoref{ch:amc} we will further generalise this view
using algebraic structures that allow us to express probabilistic inference and
other reasoning tasks within a single framework.

% Appendix Sat

\chapter{Appendix Satisfiability and Proof Theory}

\label{ch:sat}

% %---------------------------------------------------------------

Logic revolves around two tightly linked notions: \textit{consistency} and
\textit{validity} \citep{franco2009history}. Proof theory studies these notions
from a syntactic perspective by manipulating symbols using axioms and inference
rules; model theory examines them semantically by interpreting sentences over
structures that encode the ``world''. Although the two views emphasise different
objects, they coincide for complete axiom systems: a statement that can be
derived syntactically is precisely one that is true in every model, and
unsatisfiable theories are those that entail a contradiction.

The bridge between proof theory and model theory is central to this thesis.
Efficient algorithms for propositional satisfiability (SAT) allow us to reason
about the models of logic programs, while proofs about circuit properties ensure
that the compiled artefacts faithfully capture the semantics of the original
theories. Shannon's connection between Boolean logic and circuits
\citep{shannon1938symbolic} sparked a line of work that culminated in modern
knowledge compilation techniques, such as Binary Decision Diagrams (BDDs)
\citep{akers1978binary, bryant1986graph} and Sentential Decision Diagrams (SDDs).
These structures will later support our probabilistic Answer Set Programming
encodings.

% %---------------------------------------------------------------

\section{Notation}

We borrow definitions and notation from the work of \citep{arora2009computational}
and \citep{kimmig2017algebraic}. Since this chapter is focused on logical
SAT-like problems, we only introduce basic logic concepts, such as
\textit{Boolean formulas}, CNFs and \textit{Logical Propositional
Theories}.

\begin{definition}[Boolean Formulas]
    A \textit{Boolean formula}
    is the combination of \textit{Boolean variables}, that can
    be either $\top$ or $\bot$, and logical operators, such as
    $\land$ ($AND$), $\lor$ ($OR$), $\lnot$ ($NOT$, also denoted
    by an overline) \citep{arora2009computational}.
\end{definition}

\begin{example}
    For example, the formula $\phi$ defined by
    \begin{displaymath}
       \phi = (u_1 \land u_2) \lor \lnot (u_3 \land
       \overline{u}_4)
    \end{displaymath}
    is a Boolean formula over variables $u_1, u_2, u_3, u_4$.
    We denote by $\phi(a)$ the evaluation of $\phi$ over an
    assignment $a$ of the variables in the formula.

\end{example}

\begin{definition}[Conjunctive Normal Form]
    \label{def:cnf}
    A Boolean formula over variables $u_1, \ldots u_n$ is in
    CNF if it is a conjunction of clauses, where each
    clause is a disjunction of literals, and a literal is either
    a variable or its negation \citep{arora2009computational}.
    Hence, a CNF is a Boolean formula of the form
    \begin{displaymath}
        \bigwedge_i \left ( \bigvee_j v_{ij} \right ),
    \end{displaymath}

    where each $v_{ij}$ is a literal over variables $u_1,
    \ldots u_n$.
\end{definition}

\begin{example}
   For example, the following formula is a 3CNF (a CNF where
   each clause has at most 3 literals) over variables $u_1, u_2,
   u_3, u_4$:
    \begin{displaymath}
        (u_1 \lor \overline{u}_2 \lor u_3) \land (u_2 \lor
        \overline{u}_3 \lor u_4) \land (\overline{u}_1 \lor
        u_3 \lor \overline{u}_4).
    \end{displaymath}
\end{example}

\begin{definition}[Disjunctive Normal Form]
    A Boolean formula over variables $u_1, \ldots u_n$ is in
    DNF if it is a disjunction of clauses, where each
    clause is a conjunction of literals. Hence, a DNF is a
    Boolean formula of the form:
    \begin{displaymath}
        \bigvee_i \left ( \bigwedge_j v_{ij} \right ),
    \end{displaymath}
    where each $v_{ij}$ is a literal over variables $u_1,
    \ldots u_n$.
\end{definition}

\begin{definition}[Logical Propositional Theory]
    A \textit{Logical Theory} is set of logical sentences,
    Boolean-valued formulas with no free variables. Hence, a
    \textit{Propositional Theory} is Logical Theory where the
    sentences are propositional formulas, i.e., formulas with
    no quantifiers.
\end{definition}

%------------------------------------------------

\section{Satisfiability}

Propositional satisfiability (SAT) is one of the cornerstones of theoretical
computer science. Every problem in NP polynomially reduces to SAT, which
establishes its NP-completeness \citep{Cook_1971, levin1973universal}. Because
of this universality, SAT provides a convenient target for reasoning about
diverse logical theories. Later chapters will rely on SAT when translating PASP
encodings into propositional form so that we can leverage mature SAT and model
counting machinery.

In neuro-symbolic settings we seldom solve SAT just once; instead we evaluate
many related queries that differ by evidence or parameter values. This calls
for solving SAT-like problems in a way that enables reuse, motivating the
knowledge compilation techniques studied throughout this thesis. We therefore
start by recalling baseline notions of satisfiability and its counting and
optimization variants.

\subsection{Satisfiability}

The Boolean Satisfiability Problem is the problem of
determining whether a given CNF is \textit{satisfiable},
i.e., whether there is an assignment of $True$ or $False$ to the
variables that makes the formula $True$
\citep{arora2009computational}. If such an assignment does not
exist, the formula is said to be \textit{unsatisfiable}.

\begin{definition}[SAT - Satisfiability]
    Let SAT be the language of all satisfiable CNFs.
    Then, we say that for a CNF $\phi$, the SAT
    problem is defined as

    \begin{displaymath}
        \text{SAT}(\phi) = \{ \phi \mid \phi \text{ is a
        satisfiable propositional formula} \}.
    \end{displaymath}

\end{definition}

For example, $(True, False, False, False)$ is an example of
assignment that makes the 3CNF of definition \ref{def:cnf}
satisfiable. On the other hand, the CNF $x \land
\overline{x}$ is unsatisfiable, since it is a
\textit{contradiction} (the opposite of a tautology).

\subsection{MAX-SAT}

Max-SAT generalises satisfiability by searching for the assignment that
optimises how many clauses evaluate to true \citep{KRENTEL1988490}. The
classical (unweighted) variant simply counts satisfied clauses.

\begin{definition}[MAX-SAT]
    Let $\phi$ be a CNF whose clause set is $C$. The Max-SAT objective is
    \[
        \max_{a \in \{0,1\}^n} \sum_{c \in C} [\![ c(a) ]\!],
    \]
    where $[\![c(a)]\!]$ is the Iverson bracket that yields $1$ when clause $c$
    evaluates to $True$ under assignment $a$ and $0$ otherwise, and $n$ is the
    number of variables in $\phi$.
\end{definition}

We can additionally attach a non-negative weight $w(c)$ to each clause and seek
the maximum weighted sum of satisfied clauses.

\begin{definition}[Weighted MAX-SAT]
    The weighted Max-SAT problem is
    \[
        \max_{a \in \{0,1\}^n} \sum_{c \in C} w(c)\,[\![c(a)]\!].
    \]
\end{definition}

SAT is a special case of Max-SAT: a CNF is satisfiable iff the optimum equals
$|C|$. Consequently, Max-SAT is NP-hard. Setting all weights to $1$ reduces the
weighted variant to the unweighted one, confirming that the weighted problem
inherits NP-hardness. Krentel further shows that Max-SAT is OptP-complete,
placing it alongside optimisation problems such as \textsc{TSP} and
\textsc{Knapsack} \citep{KRENTEL1988490}.

\subsection{Sharp-SAT}

Unlike SAT and Max-SAT, the $\#SAT$ (Sharp-SAT) problem is a counting task: it
asks how many satisfying assignments a CNF admits \citep{valiant1979189}. This
places $\#SAT$ closer to the counting problems studied by Levin
\citep{levin1973universal} than to Cook's decision formulation \citep{Cook_1971}:
there is always an answer, but enumerating it may require exploring all
assignments rather than stopping after the first model is discovered.

Counting solutions is at least as hard as deciding their existence. Every SAT
instance can be solved by verifying whether the corresponding $\#SAT$ count is
non-zero, so $\#SAT$ is NP-hard. Valiant further proved that it is
$\#\text{P}$-complete, meaning that any counting problem associated with an
NP decision problem can be reduced to $\#SAT$.

\begin{definition}[\#SAT]
    Formally, let $\phi$ be a CNF over variables $x_1,
    \ldots, x_n$. The Sharp-SAT problem asks for the quantity
    \begin{displaymath}
        \#SAT(\phi) = \big| \{ a \in \{0,1\}^n \mid \phi(a) = True \} \big|.
    \end{displaymath}
\end{definition}

Similar to the Max-SAT problem, there is a weighted version
of the Sharp-SAT problem, called Weighted Model Counting (WMC), where a
non-negative weight is associated to each assignment of values
to variables \citep{chakraborty2015weighted}. The classical
version of the problem, usually called Model Counting (MC), can be seen as
a special case of the weighted version, where all weights are
equal to $1$, and is sometimes referred to as \textit{unweighted
model counting}.

\begin{definition}[Weighted Model Counting]
    The Weighted Model Counting problem is the problem of finding the sum of
    the weights of all assignments that satisfy a given
    CNF. Formally, let $\phi$ be a CNF over variables
    $x_1, \ldots, x_n$, and let $w: \{0,1\}^n \rightarrow
    \mathbb{R}^+$ be the weight function over the assignments of
    the variables in $\phi$. Then, the WMC problem is
    \begin{displaymath}
        \text{WMC}(\phi) = \sum_{a \in \{0,1\}^n} w(a) \cdot
        [\!\![ \phi(a) ]\!\!].
    \end{displaymath}
\end{definition}

Weighted model counting subsumes the previous variants: setting all weights to
$1$ recovers model counting, while restricting weights to $\{0,1\}$ captures
ordinary SAT. In Chapter \autoref{ch:amc} we will further generalise this view
using algebraic structures that allow us to express probabilistic inference and
other reasoning tasks within a single framework.
